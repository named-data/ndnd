// Code generated by ndn tlv codegen DO NOT EDIT.
package trust_schema

import (
	"encoding/binary"
	"io"

	enc "github.com/named-data/ndnd/std/encoding"
	"github.com/named-data/ndnd/std/ndn/spec_2022"
)

type CrossSchemaContentEncoder struct {
	Length uint

	SimpleSchemaRules_subencoder []struct {
		SimpleSchemaRules_encoder SimpleSchemaRuleEncoder
	}
	PrefixSchemaRules_subencoder []struct {
		PrefixSchemaRules_encoder PrefixSchemaRuleEncoder
	}
}

type CrossSchemaContentParsingContext struct {
	SimpleSchemaRules_context SimpleSchemaRuleParsingContext
	PrefixSchemaRules_context PrefixSchemaRuleParsingContext
}

func (encoder *CrossSchemaContentEncoder) Init(value *CrossSchemaContent) {
	{
		SimpleSchemaRules_l := len(value.SimpleSchemaRules)
		encoder.SimpleSchemaRules_subencoder = make([]struct {
			SimpleSchemaRules_encoder SimpleSchemaRuleEncoder
		}, SimpleSchemaRules_l)
		for i := 0; i < SimpleSchemaRules_l; i++ {
			pseudoEncoder := &encoder.SimpleSchemaRules_subencoder[i]
			pseudoValue := struct {
				SimpleSchemaRules *SimpleSchemaRule
			}{
				SimpleSchemaRules: value.SimpleSchemaRules[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SimpleSchemaRules != nil {
					encoder.SimpleSchemaRules_encoder.Init(value.SimpleSchemaRules)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		PrefixSchemaRules_l := len(value.PrefixSchemaRules)
		encoder.PrefixSchemaRules_subencoder = make([]struct {
			PrefixSchemaRules_encoder PrefixSchemaRuleEncoder
		}, PrefixSchemaRules_l)
		for i := 0; i < PrefixSchemaRules_l; i++ {
			pseudoEncoder := &encoder.PrefixSchemaRules_subencoder[i]
			pseudoValue := struct {
				PrefixSchemaRules *PrefixSchemaRule
			}{
				PrefixSchemaRules: value.PrefixSchemaRules[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixSchemaRules != nil {
					encoder.PrefixSchemaRules_encoder.Init(value.PrefixSchemaRules)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.SimpleSchemaRules != nil {
		for seq_i, seq_v := range value.SimpleSchemaRules {
			pseudoEncoder := &encoder.SimpleSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				SimpleSchemaRules *SimpleSchemaRule
			}{
				SimpleSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SimpleSchemaRules != nil {
					l += 3
					l += uint(enc.TLNum(encoder.SimpleSchemaRules_encoder.Length).EncodingLength())
					l += encoder.SimpleSchemaRules_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PrefixSchemaRules != nil {
		for seq_i, seq_v := range value.PrefixSchemaRules {
			pseudoEncoder := &encoder.PrefixSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				PrefixSchemaRules *PrefixSchemaRule
			}{
				PrefixSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixSchemaRules != nil {
					l += 3
					l += uint(enc.TLNum(encoder.PrefixSchemaRules_encoder.Length).EncodingLength())
					l += encoder.PrefixSchemaRules_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

func (context *CrossSchemaContentParsingContext) Init() {
	context.SimpleSchemaRules_context.Init()
	context.PrefixSchemaRules_context.Init()
}

func (encoder *CrossSchemaContentEncoder) EncodeInto(value *CrossSchemaContent, buf []byte) {

	pos := uint(0)

	if value.SimpleSchemaRules != nil {
		for seq_i, seq_v := range value.SimpleSchemaRules {
			pseudoEncoder := &encoder.SimpleSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				SimpleSchemaRules *SimpleSchemaRule
			}{
				SimpleSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.SimpleSchemaRules != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(620))
					pos += 3
					pos += uint(enc.TLNum(encoder.SimpleSchemaRules_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.SimpleSchemaRules_encoder.Length > 0 {
						encoder.SimpleSchemaRules_encoder.EncodeInto(value.SimpleSchemaRules, buf[pos:])
						pos += encoder.SimpleSchemaRules_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PrefixSchemaRules != nil {
		for seq_i, seq_v := range value.PrefixSchemaRules {
			pseudoEncoder := &encoder.PrefixSchemaRules_subencoder[seq_i]
			pseudoValue := struct {
				PrefixSchemaRules *PrefixSchemaRule
			}{
				PrefixSchemaRules: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PrefixSchemaRules != nil {
					buf[pos] = 253
					binary.BigEndian.PutUint16(buf[pos+1:], uint16(622))
					pos += 3
					pos += uint(enc.TLNum(encoder.PrefixSchemaRules_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.PrefixSchemaRules_encoder.Length > 0 {
						encoder.PrefixSchemaRules_encoder.EncodeInto(value.PrefixSchemaRules, buf[pos:])
						pos += encoder.PrefixSchemaRules_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *CrossSchemaContentEncoder) Encode(value *CrossSchemaContent) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *CrossSchemaContentParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*CrossSchemaContent, error) {

	var handled_SimpleSchemaRules bool = false
	var handled_PrefixSchemaRules bool = false

	progress := -1
	_ = progress

	value := &CrossSchemaContent{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 620:
				if true {
					handled = true
					handled_SimpleSchemaRules = true
					if value.SimpleSchemaRules == nil {
						value.SimpleSchemaRules = make([]*SimpleSchemaRule, 0)
					}
					{
						pseudoValue := struct {
							SimpleSchemaRules *SimpleSchemaRule
						}{}
						{
							value := &pseudoValue
							value.SimpleSchemaRules, err = context.SimpleSchemaRules_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.SimpleSchemaRules = append(value.SimpleSchemaRules, pseudoValue.SimpleSchemaRules)
					}
					progress--
				}
			case 622:
				if true {
					handled = true
					handled_PrefixSchemaRules = true
					if value.PrefixSchemaRules == nil {
						value.PrefixSchemaRules = make([]*PrefixSchemaRule, 0)
					}
					{
						pseudoValue := struct {
							PrefixSchemaRules *PrefixSchemaRule
						}{}
						{
							value := &pseudoValue
							value.PrefixSchemaRules, err = context.PrefixSchemaRules_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.PrefixSchemaRules = append(value.PrefixSchemaRules, pseudoValue.PrefixSchemaRules)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_SimpleSchemaRules && err == nil {
		// sequence - skip
	}
	if !handled_PrefixSchemaRules && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *CrossSchemaContent) Encode() enc.Wire {
	encoder := CrossSchemaContentEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *CrossSchemaContent) Bytes() []byte {
	return value.Encode().Join()
}

func ParseCrossSchemaContent(reader enc.WireView, ignoreCritical bool) (*CrossSchemaContent, error) {
	context := CrossSchemaContentParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type SimpleSchemaRuleEncoder struct {
	Length uint

	NamePrefix_length  uint
	KeyLocator_encoder spec_2022.KeyLocatorEncoder
}

type SimpleSchemaRuleParsingContext struct {
	KeyLocator_context spec_2022.KeyLocatorParsingContext
}

func (encoder *SimpleSchemaRuleEncoder) Init(value *SimpleSchemaRule) {
	if value.NamePrefix != nil {
		encoder.NamePrefix_length = 0
		for _, c := range value.NamePrefix {
			encoder.NamePrefix_length += uint(c.EncodingLength())
		}
	}
	if value.KeyLocator != nil {
		encoder.KeyLocator_encoder.Init(value.KeyLocator)
	}

	l := uint(0)
	if value.NamePrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NamePrefix_length).EncodingLength())
		l += encoder.NamePrefix_length
	}
	if value.KeyLocator != nil {
		l += 1
		l += uint(enc.TLNum(encoder.KeyLocator_encoder.Length).EncodingLength())
		l += encoder.KeyLocator_encoder.Length
	}
	encoder.Length = l

}

func (context *SimpleSchemaRuleParsingContext) Init() {

	context.KeyLocator_context.Init()
}

func (encoder *SimpleSchemaRuleEncoder) EncodeInto(value *SimpleSchemaRule, buf []byte) {

	pos := uint(0)

	if value.NamePrefix != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NamePrefix_length).EncodeInto(buf[pos:]))
		for _, c := range value.NamePrefix {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.KeyLocator != nil {
		buf[pos] = byte(28)
		pos += 1
		pos += uint(enc.TLNum(encoder.KeyLocator_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.KeyLocator_encoder.Length > 0 {
			encoder.KeyLocator_encoder.EncodeInto(value.KeyLocator, buf[pos:])
			pos += encoder.KeyLocator_encoder.Length
		}
	}
}

func (encoder *SimpleSchemaRuleEncoder) Encode(value *SimpleSchemaRule) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *SimpleSchemaRuleParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*SimpleSchemaRule, error) {

	var handled_NamePrefix bool = false
	var handled_KeyLocator bool = false

	progress := -1
	_ = progress

	value := &SimpleSchemaRule{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NamePrefix = true
					delegate := reader.Delegate(int(l))
					value.NamePrefix, err = delegate.ReadName()
				}
			case 28:
				if true {
					handled = true
					handled_KeyLocator = true
					value.KeyLocator, err = context.KeyLocator_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NamePrefix && err == nil {
		value.NamePrefix = nil
	}
	if !handled_KeyLocator && err == nil {
		value.KeyLocator = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *SimpleSchemaRule) Encode() enc.Wire {
	encoder := SimpleSchemaRuleEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *SimpleSchemaRule) Bytes() []byte {
	return value.Encode().Join()
}

func ParseSimpleSchemaRule(reader enc.WireView, ignoreCritical bool) (*SimpleSchemaRule, error) {
	context := SimpleSchemaRuleParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type PrefixSchemaRuleEncoder struct {
	Length uint

	NamePrefix_length uint
}

type PrefixSchemaRuleParsingContext struct {
}

func (encoder *PrefixSchemaRuleEncoder) Init(value *PrefixSchemaRule) {
	if value.NamePrefix != nil {
		encoder.NamePrefix_length = 0
		for _, c := range value.NamePrefix {
			encoder.NamePrefix_length += uint(c.EncodingLength())
		}
	}

	l := uint(0)
	if value.NamePrefix != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NamePrefix_length).EncodingLength())
		l += encoder.NamePrefix_length
	}
	encoder.Length = l

}

func (context *PrefixSchemaRuleParsingContext) Init() {

}

func (encoder *PrefixSchemaRuleEncoder) EncodeInto(value *PrefixSchemaRule, buf []byte) {

	pos := uint(0)

	if value.NamePrefix != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NamePrefix_length).EncodeInto(buf[pos:]))
		for _, c := range value.NamePrefix {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
}

func (encoder *PrefixSchemaRuleEncoder) Encode(value *PrefixSchemaRule) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *PrefixSchemaRuleParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*PrefixSchemaRule, error) {

	var handled_NamePrefix bool = false

	progress := -1
	_ = progress

	value := &PrefixSchemaRule{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NamePrefix = true
					delegate := reader.Delegate(int(l))
					value.NamePrefix, err = delegate.ReadName()
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NamePrefix && err == nil {
		value.NamePrefix = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *PrefixSchemaRule) Encode() enc.Wire {
	encoder := PrefixSchemaRuleEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *PrefixSchemaRule) Bytes() []byte {
	return value.Encode().Join()
}

func ParsePrefixSchemaRule(reader enc.WireView, ignoreCritical bool) (*PrefixSchemaRule, error) {
	context := PrefixSchemaRuleParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsUserFnArgEncoder struct {
	Length uint
}

type LvsUserFnArgParsingContext struct {
}

func (encoder *LvsUserFnArgEncoder) Init(value *LvsUserFnArg) {

	l := uint(0)
	if value.Value != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Value)).EncodingLength())
		l += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	encoder.Length = l

}

func (context *LvsUserFnArgParsingContext) Init() {

}

func (encoder *LvsUserFnArgEncoder) EncodeInto(value *LvsUserFnArg, buf []byte) {

	pos := uint(0)

	if value.Value != nil {
		buf[pos] = byte(33)
		pos += 1
		pos += uint(enc.TLNum(len(value.Value)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Value)
		pos += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		buf[pos] = byte(35)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
}

func (encoder *LvsUserFnArgEncoder) Encode(value *LvsUserFnArg) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsUserFnArgParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsUserFnArg, error) {

	var handled_Value bool = false
	var handled_Tag bool = false

	progress := -1
	_ = progress

	value := &LvsUserFnArg{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 33:
				if true {
					handled = true
					handled_Value = true
					value.Value = make([]byte, l)
					_, err = reader.ReadFull(value.Value)
				}
			case 35:
				if true {
					handled = true
					handled_Tag = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Tag.Set(optval)
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Value && err == nil {
		value.Value = nil
	}
	if !handled_Tag && err == nil {
		value.Tag.Unset()
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsUserFnArg) Encode() enc.Wire {
	encoder := LvsUserFnArgEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsUserFnArg) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsUserFnArg(reader enc.WireView, ignoreCritical bool) (*LvsUserFnArg, error) {
	context := LvsUserFnArgParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsUserFnCallEncoder struct {
	Length uint

	Args_subencoder []struct {
		Args_encoder LvsUserFnArgEncoder
	}
}

type LvsUserFnCallParsingContext struct {
	Args_context LvsUserFnArgParsingContext
}

func (encoder *LvsUserFnCallEncoder) Init(value *LvsUserFnCall) {

	{
		Args_l := len(value.Args)
		encoder.Args_subencoder = make([]struct {
			Args_encoder LvsUserFnArgEncoder
		}, Args_l)
		for i := 0; i < Args_l; i++ {
			pseudoEncoder := &encoder.Args_subencoder[i]
			pseudoValue := struct {
				Args *LvsUserFnArg
			}{
				Args: value.Args[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Args != nil {
					encoder.Args_encoder.Init(value.Args)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.FnId != nil {
		l += 1
		l += uint(enc.TLNum(len(value.FnId)).EncodingLength())
		l += uint(len(value.FnId))
	}
	if value.Args != nil {
		for seq_i, seq_v := range value.Args {
			pseudoEncoder := &encoder.Args_subencoder[seq_i]
			pseudoValue := struct {
				Args *LvsUserFnArg
			}{
				Args: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Args != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Args_encoder.Length).EncodingLength())
					l += encoder.Args_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

func (context *LvsUserFnCallParsingContext) Init() {

	context.Args_context.Init()
}

func (encoder *LvsUserFnCallEncoder) EncodeInto(value *LvsUserFnCall, buf []byte) {

	pos := uint(0)

	if value.FnId != nil {
		buf[pos] = byte(39)
		pos += 1
		pos += uint(enc.TLNum(len(value.FnId)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.FnId)
		pos += uint(len(value.FnId))
	}
	if value.Args != nil {
		for seq_i, seq_v := range value.Args {
			pseudoEncoder := &encoder.Args_subencoder[seq_i]
			pseudoValue := struct {
				Args *LvsUserFnArg
			}{
				Args: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Args != nil {
					buf[pos] = byte(51)
					pos += 1
					pos += uint(enc.TLNum(encoder.Args_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Args_encoder.Length > 0 {
						encoder.Args_encoder.EncodeInto(value.Args, buf[pos:])
						pos += encoder.Args_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *LvsUserFnCallEncoder) Encode(value *LvsUserFnCall) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsUserFnCallParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsUserFnCall, error) {

	var handled_FnId bool = false
	var handled_Args bool = false

	progress := -1
	_ = progress

	value := &LvsUserFnCall{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 39:
				if true {
					handled = true
					handled_FnId = true
					value.FnId = make([]byte, l)
					_, err = reader.ReadFull(value.FnId)
				}
			case 51:
				if true {
					handled = true
					handled_Args = true
					if value.Args == nil {
						value.Args = make([]*LvsUserFnArg, 0)
					}
					{
						pseudoValue := struct {
							Args *LvsUserFnArg
						}{}
						{
							value := &pseudoValue
							value.Args, err = context.Args_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Args = append(value.Args, pseudoValue.Args)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_FnId && err == nil {
		value.FnId = nil
	}
	if !handled_Args && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsUserFnCall) Encode() enc.Wire {
	encoder := LvsUserFnCallEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsUserFnCall) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsUserFnCall(reader enc.WireView, ignoreCritical bool) (*LvsUserFnCall, error) {
	context := LvsUserFnCallParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsConstraintOptionEncoder struct {
	Length uint

	Fn_encoder LvsUserFnCallEncoder
}

type LvsConstraintOptionParsingContext struct {
	Fn_context LvsUserFnCallParsingContext
}

func (encoder *LvsConstraintOptionEncoder) Init(value *LvsConstraintOption) {

	if value.Fn != nil {
		encoder.Fn_encoder.Init(value.Fn)
	}

	l := uint(0)
	if value.Value != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Value)).EncodingLength())
		l += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Fn != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Fn_encoder.Length).EncodingLength())
		l += encoder.Fn_encoder.Length
	}
	encoder.Length = l

}

func (context *LvsConstraintOptionParsingContext) Init() {

	context.Fn_context.Init()
}

func (encoder *LvsConstraintOptionEncoder) EncodeInto(value *LvsConstraintOption, buf []byte) {

	pos := uint(0)

	if value.Value != nil {
		buf[pos] = byte(33)
		pos += 1
		pos += uint(enc.TLNum(len(value.Value)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Value)
		pos += uint(len(value.Value))
	}
	if optval, ok := value.Tag.Get(); ok {
		buf[pos] = byte(35)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.Fn != nil {
		buf[pos] = byte(49)
		pos += 1
		pos += uint(enc.TLNum(encoder.Fn_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Fn_encoder.Length > 0 {
			encoder.Fn_encoder.EncodeInto(value.Fn, buf[pos:])
			pos += encoder.Fn_encoder.Length
		}
	}
}

func (encoder *LvsConstraintOptionEncoder) Encode(value *LvsConstraintOption) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsConstraintOptionParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsConstraintOption, error) {

	var handled_Value bool = false
	var handled_Tag bool = false
	var handled_Fn bool = false

	progress := -1
	_ = progress

	value := &LvsConstraintOption{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 33:
				if true {
					handled = true
					handled_Value = true
					value.Value = make([]byte, l)
					_, err = reader.ReadFull(value.Value)
				}
			case 35:
				if true {
					handled = true
					handled_Tag = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Tag.Set(optval)
					}
				}
			case 49:
				if true {
					handled = true
					handled_Fn = true
					value.Fn, err = context.Fn_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Value && err == nil {
		value.Value = nil
	}
	if !handled_Tag && err == nil {
		value.Tag.Unset()
	}
	if !handled_Fn && err == nil {
		value.Fn = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsConstraintOption) Encode() enc.Wire {
	encoder := LvsConstraintOptionEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsConstraintOption) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsConstraintOption(reader enc.WireView, ignoreCritical bool) (*LvsConstraintOption, error) {
	context := LvsConstraintOptionParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsPatternConstraintEncoder struct {
	Length uint

	ConsOptions_subencoder []struct {
		ConsOptions_encoder LvsConstraintOptionEncoder
	}
}

type LvsPatternConstraintParsingContext struct {
	ConsOptions_context LvsConstraintOptionParsingContext
}

func (encoder *LvsPatternConstraintEncoder) Init(value *LvsPatternConstraint) {
	{
		ConsOptions_l := len(value.ConsOptions)
		encoder.ConsOptions_subencoder = make([]struct {
			ConsOptions_encoder LvsConstraintOptionEncoder
		}, ConsOptions_l)
		for i := 0; i < ConsOptions_l; i++ {
			pseudoEncoder := &encoder.ConsOptions_subencoder[i]
			pseudoValue := struct {
				ConsOptions *LvsConstraintOption
			}{
				ConsOptions: value.ConsOptions[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsOptions != nil {
					encoder.ConsOptions_encoder.Init(value.ConsOptions)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.ConsOptions != nil {
		for seq_i, seq_v := range value.ConsOptions {
			pseudoEncoder := &encoder.ConsOptions_subencoder[seq_i]
			pseudoValue := struct {
				ConsOptions *LvsConstraintOption
			}{
				ConsOptions: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsOptions != nil {
					l += 1
					l += uint(enc.TLNum(encoder.ConsOptions_encoder.Length).EncodingLength())
					l += encoder.ConsOptions_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

func (context *LvsPatternConstraintParsingContext) Init() {
	context.ConsOptions_context.Init()
}

func (encoder *LvsPatternConstraintEncoder) EncodeInto(value *LvsPatternConstraint, buf []byte) {

	pos := uint(0)

	if value.ConsOptions != nil {
		for seq_i, seq_v := range value.ConsOptions {
			pseudoEncoder := &encoder.ConsOptions_subencoder[seq_i]
			pseudoValue := struct {
				ConsOptions *LvsConstraintOption
			}{
				ConsOptions: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsOptions != nil {
					buf[pos] = byte(65)
					pos += 1
					pos += uint(enc.TLNum(encoder.ConsOptions_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.ConsOptions_encoder.Length > 0 {
						encoder.ConsOptions_encoder.EncodeInto(value.ConsOptions, buf[pos:])
						pos += encoder.ConsOptions_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *LvsPatternConstraintEncoder) Encode(value *LvsPatternConstraint) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsPatternConstraintParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsPatternConstraint, error) {

	var handled_ConsOptions bool = false

	progress := -1
	_ = progress

	value := &LvsPatternConstraint{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 65:
				if true {
					handled = true
					handled_ConsOptions = true
					if value.ConsOptions == nil {
						value.ConsOptions = make([]*LvsConstraintOption, 0)
					}
					{
						pseudoValue := struct {
							ConsOptions *LvsConstraintOption
						}{}
						{
							value := &pseudoValue
							value.ConsOptions, err = context.ConsOptions_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.ConsOptions = append(value.ConsOptions, pseudoValue.ConsOptions)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_ConsOptions && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsPatternConstraint) Encode() enc.Wire {
	encoder := LvsPatternConstraintEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsPatternConstraint) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsPatternConstraint(reader enc.WireView, ignoreCritical bool) (*LvsPatternConstraint, error) {
	context := LvsPatternConstraintParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsPatternEdgeEncoder struct {
	Length uint

	ConsSets_subencoder []struct {
		ConsSets_encoder LvsPatternConstraintEncoder
	}
}

type LvsPatternEdgeParsingContext struct {
	ConsSets_context LvsPatternConstraintParsingContext
}

func (encoder *LvsPatternEdgeEncoder) Init(value *LvsPatternEdge) {

	{
		ConsSets_l := len(value.ConsSets)
		encoder.ConsSets_subencoder = make([]struct {
			ConsSets_encoder LvsPatternConstraintEncoder
		}, ConsSets_l)
		for i := 0; i < ConsSets_l; i++ {
			pseudoEncoder := &encoder.ConsSets_subencoder[i]
			pseudoValue := struct {
				ConsSets *LvsPatternConstraint
			}{
				ConsSets: value.ConsSets[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsSets != nil {
					encoder.ConsSets_encoder.Init(value.ConsSets)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Dest).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.Tag).EncodingLength())
	if value.ConsSets != nil {
		for seq_i, seq_v := range value.ConsSets {
			pseudoEncoder := &encoder.ConsSets_subencoder[seq_i]
			pseudoValue := struct {
				ConsSets *LvsPatternConstraint
			}{
				ConsSets: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsSets != nil {
					l += 1
					l += uint(enc.TLNum(encoder.ConsSets_encoder.Length).EncodingLength())
					l += encoder.ConsSets_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

func (context *LvsPatternEdgeParsingContext) Init() {

	context.ConsSets_context.Init()
}

func (encoder *LvsPatternEdgeEncoder) EncodeInto(value *LvsPatternEdge, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Dest).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(35)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Tag).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.ConsSets != nil {
		for seq_i, seq_v := range value.ConsSets {
			pseudoEncoder := &encoder.ConsSets_subencoder[seq_i]
			pseudoValue := struct {
				ConsSets *LvsPatternConstraint
			}{
				ConsSets: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.ConsSets != nil {
					buf[pos] = byte(67)
					pos += 1
					pos += uint(enc.TLNum(encoder.ConsSets_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.ConsSets_encoder.Length > 0 {
						encoder.ConsSets_encoder.EncodeInto(value.ConsSets, buf[pos:])
						pos += encoder.ConsSets_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *LvsPatternEdgeEncoder) Encode(value *LvsPatternEdge) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsPatternEdgeParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsPatternEdge, error) {

	var handled_Dest bool = false
	var handled_Tag bool = false
	var handled_ConsSets bool = false

	progress := -1
	_ = progress

	value := &LvsPatternEdge{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 37:
				if true {
					handled = true
					handled_Dest = true
					value.Dest = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Dest = uint64(value.Dest<<8) | uint64(x)
						}
					}
				}
			case 35:
				if true {
					handled = true
					handled_Tag = true
					value.Tag = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Tag = uint64(value.Tag<<8) | uint64(x)
						}
					}
				}
			case 67:
				if true {
					handled = true
					handled_ConsSets = true
					if value.ConsSets == nil {
						value.ConsSets = make([]*LvsPatternConstraint, 0)
					}
					{
						pseudoValue := struct {
							ConsSets *LvsPatternConstraint
						}{}
						{
							value := &pseudoValue
							value.ConsSets, err = context.ConsSets_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.ConsSets = append(value.ConsSets, pseudoValue.ConsSets)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Dest && err == nil {
		err = enc.ErrSkipRequired{Name: "Dest", TypeNum: 37}
	}
	if !handled_Tag && err == nil {
		err = enc.ErrSkipRequired{Name: "Tag", TypeNum: 35}
	}
	if !handled_ConsSets && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsPatternEdge) Encode() enc.Wire {
	encoder := LvsPatternEdgeEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsPatternEdge) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsPatternEdge(reader enc.WireView, ignoreCritical bool) (*LvsPatternEdge, error) {
	context := LvsPatternEdgeParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsValueEdgeEncoder struct {
	Length uint
}

type LvsValueEdgeParsingContext struct {
}

func (encoder *LvsValueEdgeEncoder) Init(value *LvsValueEdge) {

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Dest).EncodingLength())
	if value.Value != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Value)).EncodingLength())
		l += uint(len(value.Value))
	}
	encoder.Length = l

}

func (context *LvsValueEdgeParsingContext) Init() {

}

func (encoder *LvsValueEdgeEncoder) EncodeInto(value *LvsValueEdge, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Dest).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.Value != nil {
		buf[pos] = byte(33)
		pos += 1
		pos += uint(enc.TLNum(len(value.Value)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Value)
		pos += uint(len(value.Value))
	}
}

func (encoder *LvsValueEdgeEncoder) Encode(value *LvsValueEdge) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsValueEdgeParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsValueEdge, error) {

	var handled_Dest bool = false
	var handled_Value bool = false

	progress := -1
	_ = progress

	value := &LvsValueEdge{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 37:
				if true {
					handled = true
					handled_Dest = true
					value.Dest = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Dest = uint64(value.Dest<<8) | uint64(x)
						}
					}
				}
			case 33:
				if true {
					handled = true
					handled_Value = true
					value.Value = make([]byte, l)
					_, err = reader.ReadFull(value.Value)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Dest && err == nil {
		err = enc.ErrSkipRequired{Name: "Dest", TypeNum: 37}
	}
	if !handled_Value && err == nil {
		value.Value = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsValueEdge) Encode() enc.Wire {
	encoder := LvsValueEdgeEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsValueEdge) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsValueEdge(reader enc.WireView, ignoreCritical bool) (*LvsValueEdge, error) {
	context := LvsValueEdgeParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsNodeEncoder struct {
	Length uint

	RuleName_subencoder []struct {
	}
	Edges_subencoder []struct {
		Edges_encoder LvsValueEdgeEncoder
	}
	PatternEdges_subencoder []struct {
		PatternEdges_encoder LvsPatternEdgeEncoder
	}
	SignCons_subencoder []struct {
	}
}

type LvsNodeParsingContext struct {
	Edges_context        LvsValueEdgeParsingContext
	PatternEdges_context LvsPatternEdgeParsingContext
}

func (encoder *LvsNodeEncoder) Init(value *LvsNode) {

	{
		RuleName_l := len(value.RuleName)
		encoder.RuleName_subencoder = make([]struct {
		}, RuleName_l)
		for i := 0; i < RuleName_l; i++ {
			pseudoEncoder := &encoder.RuleName_subencoder[i]
			pseudoValue := struct {
				RuleName []byte
			}{
				RuleName: value.RuleName[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}
	{
		Edges_l := len(value.Edges)
		encoder.Edges_subencoder = make([]struct {
			Edges_encoder LvsValueEdgeEncoder
		}, Edges_l)
		for i := 0; i < Edges_l; i++ {
			pseudoEncoder := &encoder.Edges_subencoder[i]
			pseudoValue := struct {
				Edges *LvsValueEdge
			}{
				Edges: value.Edges[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Edges != nil {
					encoder.Edges_encoder.Init(value.Edges)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		PatternEdges_l := len(value.PatternEdges)
		encoder.PatternEdges_subencoder = make([]struct {
			PatternEdges_encoder LvsPatternEdgeEncoder
		}, PatternEdges_l)
		for i := 0; i < PatternEdges_l; i++ {
			pseudoEncoder := &encoder.PatternEdges_subencoder[i]
			pseudoValue := struct {
				PatternEdges *LvsPatternEdge
			}{
				PatternEdges: value.PatternEdges[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PatternEdges != nil {
					encoder.PatternEdges_encoder.Init(value.PatternEdges)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		SignCons_l := len(value.SignCons)
		encoder.SignCons_subencoder = make([]struct {
		}, SignCons_l)
		for i := 0; i < SignCons_l; i++ {
			pseudoEncoder := &encoder.SignCons_subencoder[i]
			pseudoValue := struct {
				SignCons uint64
			}{
				SignCons: value.SignCons[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue

				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Id).EncodingLength())
	if optval, ok := value.Parent.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.RuleName != nil {
		for seq_i, seq_v := range value.RuleName {
			pseudoEncoder := &encoder.RuleName_subencoder[seq_i]
			pseudoValue := struct {
				RuleName []byte
			}{
				RuleName: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.RuleName != nil {
					l += 1
					l += uint(enc.TLNum(len(value.RuleName)).EncodingLength())
					l += uint(len(value.RuleName))
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Edges != nil {
		for seq_i, seq_v := range value.Edges {
			pseudoEncoder := &encoder.Edges_subencoder[seq_i]
			pseudoValue := struct {
				Edges *LvsValueEdge
			}{
				Edges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Edges != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Edges_encoder.Length).EncodingLength())
					l += encoder.Edges_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PatternEdges != nil {
		for seq_i, seq_v := range value.PatternEdges {
			pseudoEncoder := &encoder.PatternEdges_subencoder[seq_i]
			pseudoValue := struct {
				PatternEdges *LvsPatternEdge
			}{
				PatternEdges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PatternEdges != nil {
					l += 1
					l += uint(enc.TLNum(encoder.PatternEdges_encoder.Length).EncodingLength())
					l += encoder.PatternEdges_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.SignCons != nil {
		for seq_i, seq_v := range value.SignCons {
			pseudoEncoder := &encoder.SignCons_subencoder[seq_i]
			pseudoValue := struct {
				SignCons uint64
			}{
				SignCons: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				l += 1
				l += uint(1 + enc.Nat(value.SignCons).EncodingLength())
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

func (context *LvsNodeParsingContext) Init() {

	context.Edges_context.Init()
	context.PatternEdges_context.Init()

}

func (encoder *LvsNodeEncoder) EncodeInto(value *LvsNode, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Id).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if optval, ok := value.Parent.Get(); ok {
		buf[pos] = byte(87)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.RuleName != nil {
		for seq_i, seq_v := range value.RuleName {
			pseudoEncoder := &encoder.RuleName_subencoder[seq_i]
			pseudoValue := struct {
				RuleName []byte
			}{
				RuleName: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.RuleName != nil {
					buf[pos] = byte(41)
					pos += 1
					pos += uint(enc.TLNum(len(value.RuleName)).EncodeInto(buf[pos:]))
					copy(buf[pos:], value.RuleName)
					pos += uint(len(value.RuleName))
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Edges != nil {
		for seq_i, seq_v := range value.Edges {
			pseudoEncoder := &encoder.Edges_subencoder[seq_i]
			pseudoValue := struct {
				Edges *LvsValueEdge
			}{
				Edges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Edges != nil {
					buf[pos] = byte(81)
					pos += 1
					pos += uint(enc.TLNum(encoder.Edges_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Edges_encoder.Length > 0 {
						encoder.Edges_encoder.EncodeInto(value.Edges, buf[pos:])
						pos += encoder.Edges_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.PatternEdges != nil {
		for seq_i, seq_v := range value.PatternEdges {
			pseudoEncoder := &encoder.PatternEdges_subencoder[seq_i]
			pseudoValue := struct {
				PatternEdges *LvsPatternEdge
			}{
				PatternEdges: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.PatternEdges != nil {
					buf[pos] = byte(83)
					pos += 1
					pos += uint(enc.TLNum(encoder.PatternEdges_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.PatternEdges_encoder.Length > 0 {
						encoder.PatternEdges_encoder.EncodeInto(value.PatternEdges, buf[pos:])
						pos += encoder.PatternEdges_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.SignCons != nil {
		for seq_i, seq_v := range value.SignCons {
			pseudoEncoder := &encoder.SignCons_subencoder[seq_i]
			pseudoValue := struct {
				SignCons uint64
			}{
				SignCons: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				buf[pos] = byte(85)
				pos += 1

				buf[pos] = byte(enc.Nat(value.SignCons).EncodeInto(buf[pos+1:]))
				pos += uint(1 + buf[pos])
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *LvsNodeEncoder) Encode(value *LvsNode) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsNodeParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsNode, error) {

	var handled_Id bool = false
	var handled_Parent bool = false
	var handled_RuleName bool = false
	var handled_Edges bool = false
	var handled_PatternEdges bool = false
	var handled_SignCons bool = false

	progress := -1
	_ = progress

	value := &LvsNode{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 37:
				if true {
					handled = true
					handled_Id = true
					value.Id = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Id = uint64(value.Id<<8) | uint64(x)
						}
					}
				}
			case 87:
				if true {
					handled = true
					handled_Parent = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Parent.Set(optval)
					}
				}
			case 41:
				if true {
					handled = true
					handled_RuleName = true
					if value.RuleName == nil {
						value.RuleName = make([][]byte, 0)
					}
					{
						pseudoValue := struct {
							RuleName []byte
						}{}
						{
							value := &pseudoValue
							value.RuleName = make([]byte, l)
							_, err = reader.ReadFull(value.RuleName)
							_ = value
						}
						value.RuleName = append(value.RuleName, pseudoValue.RuleName)
					}
					progress--
				}
			case 81:
				if true {
					handled = true
					handled_Edges = true
					if value.Edges == nil {
						value.Edges = make([]*LvsValueEdge, 0)
					}
					{
						pseudoValue := struct {
							Edges *LvsValueEdge
						}{}
						{
							value := &pseudoValue
							value.Edges, err = context.Edges_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Edges = append(value.Edges, pseudoValue.Edges)
					}
					progress--
				}
			case 83:
				if true {
					handled = true
					handled_PatternEdges = true
					if value.PatternEdges == nil {
						value.PatternEdges = make([]*LvsPatternEdge, 0)
					}
					{
						pseudoValue := struct {
							PatternEdges *LvsPatternEdge
						}{}
						{
							value := &pseudoValue
							value.PatternEdges, err = context.PatternEdges_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.PatternEdges = append(value.PatternEdges, pseudoValue.PatternEdges)
					}
					progress--
				}
			case 85:
				if true {
					handled = true
					handled_SignCons = true
					if value.SignCons == nil {
						value.SignCons = make([]uint64, 0)
					}
					{
						pseudoValue := struct {
							SignCons uint64
						}{}
						{
							value := &pseudoValue
							value.SignCons = uint64(0)
							{
								for i := 0; i < int(l); i++ {
									x := byte(0)
									x, err = reader.ReadByte()
									if err != nil {
										if err == io.EOF {
											err = io.ErrUnexpectedEOF
										}
										break
									}
									value.SignCons = uint64(value.SignCons<<8) | uint64(x)
								}
							}
							_ = value
						}
						value.SignCons = append(value.SignCons, pseudoValue.SignCons)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Id && err == nil {
		err = enc.ErrSkipRequired{Name: "Id", TypeNum: 37}
	}
	if !handled_Parent && err == nil {
		value.Parent.Unset()
	}
	if !handled_RuleName && err == nil {
		// sequence - skip
	}
	if !handled_Edges && err == nil {
		// sequence - skip
	}
	if !handled_PatternEdges && err == nil {
		// sequence - skip
	}
	if !handled_SignCons && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsNode) Encode() enc.Wire {
	encoder := LvsNodeEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsNode) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsNode(reader enc.WireView, ignoreCritical bool) (*LvsNode, error) {
	context := LvsNodeParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsTagSymbolEncoder struct {
	Length uint
}

type LvsTagSymbolParsingContext struct {
}

func (encoder *LvsTagSymbolEncoder) Init(value *LvsTagSymbol) {

	l := uint(0)
	if optval, ok := value.Tag.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Ident != nil {
		l += 1
		l += uint(enc.TLNum(len(value.Ident)).EncodingLength())
		l += uint(len(value.Ident))
	}
	encoder.Length = l

}

func (context *LvsTagSymbolParsingContext) Init() {

}

func (encoder *LvsTagSymbolEncoder) EncodeInto(value *LvsTagSymbol, buf []byte) {

	pos := uint(0)

	if optval, ok := value.Tag.Get(); ok {
		buf[pos] = byte(35)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.Ident != nil {
		buf[pos] = byte(41)
		pos += 1
		pos += uint(enc.TLNum(len(value.Ident)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.Ident)
		pos += uint(len(value.Ident))
	}
}

func (encoder *LvsTagSymbolEncoder) Encode(value *LvsTagSymbol) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsTagSymbolParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsTagSymbol, error) {

	var handled_Tag bool = false
	var handled_Ident bool = false

	progress := -1
	_ = progress

	value := &LvsTagSymbol{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 35:
				if true {
					handled = true
					handled_Tag = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Tag.Set(optval)
					}
				}
			case 41:
				if true {
					handled = true
					handled_Ident = true
					value.Ident = make([]byte, l)
					_, err = reader.ReadFull(value.Ident)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Tag && err == nil {
		value.Tag.Unset()
	}
	if !handled_Ident && err == nil {
		value.Ident = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsTagSymbol) Encode() enc.Wire {
	encoder := LvsTagSymbolEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsTagSymbol) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsTagSymbol(reader enc.WireView, ignoreCritical bool) (*LvsTagSymbol, error) {
	context := LvsTagSymbolParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type LvsModelEncoder struct {
	Length uint

	Nodes_subencoder []struct {
		Nodes_encoder LvsNodeEncoder
	}
	Symbols_subencoder []struct {
		Symbols_encoder LvsTagSymbolEncoder
	}
}

type LvsModelParsingContext struct {
	Nodes_context   LvsNodeParsingContext
	Symbols_context LvsTagSymbolParsingContext
}

func (encoder *LvsModelEncoder) Init(value *LvsModel) {

	{
		Nodes_l := len(value.Nodes)
		encoder.Nodes_subencoder = make([]struct {
			Nodes_encoder LvsNodeEncoder
		}, Nodes_l)
		for i := 0; i < Nodes_l; i++ {
			pseudoEncoder := &encoder.Nodes_subencoder[i]
			pseudoValue := struct {
				Nodes *LvsNode
			}{
				Nodes: value.Nodes[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Nodes != nil {
					encoder.Nodes_encoder.Init(value.Nodes)
				}
				_ = encoder
				_ = value
			}
		}
	}
	{
		Symbols_l := len(value.Symbols)
		encoder.Symbols_subencoder = make([]struct {
			Symbols_encoder LvsTagSymbolEncoder
		}, Symbols_l)
		for i := 0; i < Symbols_l; i++ {
			pseudoEncoder := &encoder.Symbols_subencoder[i]
			pseudoValue := struct {
				Symbols *LvsTagSymbol
			}{
				Symbols: value.Symbols[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Symbols != nil {
					encoder.Symbols_encoder.Init(value.Symbols)
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	l += 1
	l += uint(1 + enc.Nat(value.Version).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.StartId).EncodingLength())
	l += 1
	l += uint(1 + enc.Nat(value.NamedPatternCnt).EncodingLength())
	if value.Nodes != nil {
		for seq_i, seq_v := range value.Nodes {
			pseudoEncoder := &encoder.Nodes_subencoder[seq_i]
			pseudoValue := struct {
				Nodes *LvsNode
			}{
				Nodes: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Nodes != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Nodes_encoder.Length).EncodingLength())
					l += encoder.Nodes_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Symbols != nil {
		for seq_i, seq_v := range value.Symbols {
			pseudoEncoder := &encoder.Symbols_subencoder[seq_i]
			pseudoValue := struct {
				Symbols *LvsTagSymbol
			}{
				Symbols: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Symbols != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Symbols_encoder.Length).EncodingLength())
					l += encoder.Symbols_encoder.Length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

func (context *LvsModelParsingContext) Init() {

	context.Nodes_context.Init()
	context.Symbols_context.Init()
}

func (encoder *LvsModelEncoder) EncodeInto(value *LvsModel, buf []byte) {

	pos := uint(0)

	buf[pos] = byte(97)
	pos += 1

	buf[pos] = byte(enc.Nat(value.Version).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(37)
	pos += 1

	buf[pos] = byte(enc.Nat(value.StartId).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	buf[pos] = byte(105)
	pos += 1

	buf[pos] = byte(enc.Nat(value.NamedPatternCnt).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
	if value.Nodes != nil {
		for seq_i, seq_v := range value.Nodes {
			pseudoEncoder := &encoder.Nodes_subencoder[seq_i]
			pseudoValue := struct {
				Nodes *LvsNode
			}{
				Nodes: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Nodes != nil {
					buf[pos] = byte(99)
					pos += 1
					pos += uint(enc.TLNum(encoder.Nodes_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Nodes_encoder.Length > 0 {
						encoder.Nodes_encoder.EncodeInto(value.Nodes, buf[pos:])
						pos += encoder.Nodes_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
	if value.Symbols != nil {
		for seq_i, seq_v := range value.Symbols {
			pseudoEncoder := &encoder.Symbols_subencoder[seq_i]
			pseudoValue := struct {
				Symbols *LvsTagSymbol
			}{
				Symbols: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Symbols != nil {
					buf[pos] = byte(103)
					pos += 1
					pos += uint(enc.TLNum(encoder.Symbols_encoder.Length).EncodeInto(buf[pos:]))
					if encoder.Symbols_encoder.Length > 0 {
						encoder.Symbols_encoder.EncodeInto(value.Symbols, buf[pos:])
						pos += encoder.Symbols_encoder.Length
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *LvsModelEncoder) Encode(value *LvsModel) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *LvsModelParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*LvsModel, error) {

	var handled_Version bool = false
	var handled_StartId bool = false
	var handled_NamedPatternCnt bool = false
	var handled_Nodes bool = false
	var handled_Symbols bool = false

	progress := -1
	_ = progress

	value := &LvsModel{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 97:
				if true {
					handled = true
					handled_Version = true
					value.Version = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Version = uint64(value.Version<<8) | uint64(x)
						}
					}
				}
			case 37:
				if true {
					handled = true
					handled_StartId = true
					value.StartId = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.StartId = uint64(value.StartId<<8) | uint64(x)
						}
					}
				}
			case 105:
				if true {
					handled = true
					handled_NamedPatternCnt = true
					value.NamedPatternCnt = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.NamedPatternCnt = uint64(value.NamedPatternCnt<<8) | uint64(x)
						}
					}
				}
			case 99:
				if true {
					handled = true
					handled_Nodes = true
					if value.Nodes == nil {
						value.Nodes = make([]*LvsNode, 0)
					}
					{
						pseudoValue := struct {
							Nodes *LvsNode
						}{}
						{
							value := &pseudoValue
							value.Nodes, err = context.Nodes_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Nodes = append(value.Nodes, pseudoValue.Nodes)
					}
					progress--
				}
			case 103:
				if true {
					handled = true
					handled_Symbols = true
					if value.Symbols == nil {
						value.Symbols = make([]*LvsTagSymbol, 0)
					}
					{
						pseudoValue := struct {
							Symbols *LvsTagSymbol
						}{}
						{
							value := &pseudoValue
							value.Symbols, err = context.Symbols_context.Parse(reader.Delegate(int(l)), ignoreCritical)
							_ = value
						}
						value.Symbols = append(value.Symbols, pseudoValue.Symbols)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Version && err == nil {
		err = enc.ErrSkipRequired{Name: "Version", TypeNum: 97}
	}
	if !handled_StartId && err == nil {
		err = enc.ErrSkipRequired{Name: "StartId", TypeNum: 37}
	}
	if !handled_NamedPatternCnt && err == nil {
		err = enc.ErrSkipRequired{Name: "NamedPatternCnt", TypeNum: 105}
	}
	if !handled_Nodes && err == nil {
		// sequence - skip
	}
	if !handled_Symbols && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *LvsModel) Encode() enc.Wire {
	encoder := LvsModelEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *LvsModel) Bytes() []byte {
	return value.Encode().Join()
}

func ParseLvsModel(reader enc.WireView, ignoreCritical bool) (*LvsModel, error) {
	context := LvsModelParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
