// Code generated by ndn tlv codegen DO NOT EDIT.
package defn

import (
	"encoding/binary"
	"io"

	"time"

	enc "github.com/named-data/ndnd/std/encoding"
)

type FwPacketEncoder struct {
	Length uint

	wirePlan []uint

	Interest_encoder FwInterestEncoder
	Data_encoder     FwDataEncoder
	LpPacket_encoder FwLpPacketEncoder
}

type FwPacketParsingContext struct {
	Interest_context FwInterestParsingContext
	Data_context     FwDataParsingContext
	LpPacket_context FwLpPacketParsingContext
}

func (encoder *FwPacketEncoder) Init(value *FwPacket) {
	if value.Interest != nil {
		encoder.Interest_encoder.Init(value.Interest)
	}
	if value.Data != nil {
		encoder.Data_encoder.Init(value.Data)
	}
	if value.LpPacket != nil {
		encoder.LpPacket_encoder.Init(value.LpPacket)
	}

	l := uint(0)
	if value.Interest != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Interest_encoder.Length).EncodingLength())
		l += encoder.Interest_encoder.Length
	}
	if value.Data != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Data_encoder.Length).EncodingLength())
		l += encoder.Data_encoder.Length
	}
	if value.LpPacket != nil {
		l += 1
		l += uint(enc.TLNum(encoder.LpPacket_encoder.Length).EncodingLength())
		l += encoder.LpPacket_encoder.Length
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Interest != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Interest_encoder.Length).EncodingLength())
		if encoder.Interest_encoder.Length > 0 {
			l += encoder.Interest_encoder.wirePlan[0]
			for i := 1; i < len(encoder.Interest_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.Interest_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	if value.Data != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Data_encoder.Length).EncodingLength())
		if encoder.Data_encoder.Length > 0 {
			l += encoder.Data_encoder.wirePlan[0]
			for i := 1; i < len(encoder.Data_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.Data_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	if value.LpPacket != nil {
		l += 1
		l += uint(enc.TLNum(encoder.LpPacket_encoder.Length).EncodingLength())
		if encoder.LpPacket_encoder.Length > 0 {
			l += encoder.LpPacket_encoder.wirePlan[0]
			for i := 1; i < len(encoder.LpPacket_encoder.wirePlan); i++ {
				wirePlan = append(wirePlan, l)
				l = 0
				l = encoder.LpPacket_encoder.wirePlan[i]
			}
			if l == 0 {
				wirePlan = append(wirePlan, l)
				l = 0
			}
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *FwPacketParsingContext) Init() {
	context.Interest_context.Init()
	context.Data_context.Init()
	context.LpPacket_context.Init()
}

func (encoder *FwPacketEncoder) EncodeInto(value *FwPacket, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.Interest != nil {
		buf[pos] = byte(5)
		pos += 1
		pos += uint(enc.TLNum(encoder.Interest_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Interest_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.Interest_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.Interest_encoder.EncodeInto(value.Interest, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.Interest_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
	if value.Data != nil {
		buf[pos] = byte(6)
		pos += 1
		pos += uint(enc.TLNum(encoder.Data_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Data_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.Data_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.Data_encoder.EncodeInto(value.Data, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.Data_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
	if value.LpPacket != nil {
		buf[pos] = byte(100)
		pos += 1
		pos += uint(enc.TLNum(encoder.LpPacket_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.LpPacket_encoder.Length > 0 {
			{
				subWire := make(enc.Wire, len(encoder.LpPacket_encoder.wirePlan))
				subWire[0] = buf[pos:]
				for i := 1; i < len(subWire); i++ {
					subWire[i] = wire[wireIdx+i]
				}
				encoder.LpPacket_encoder.EncodeInto(value.LpPacket, subWire)
				for i := 1; i < len(subWire); i++ {
					wire[wireIdx+i] = subWire[i]
				}
				if lastL := encoder.LpPacket_encoder.wirePlan[len(subWire)-1]; lastL > 0 {
					wireIdx += len(subWire) - 1
					if len(subWire) > 1 {
						pos = lastL
					} else {
						pos += lastL
					}
				} else {
					wireIdx += len(subWire)
					pos = 0
				}
				if wireIdx < len(wire) {
					buf = wire[wireIdx]
				} else {
					buf = nil
				}
			}
		}
	}
}

func (encoder *FwPacketEncoder) Encode(value *FwPacket) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *FwPacketParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwPacket, error) {

	var handled_Interest bool = false
	var handled_Data bool = false
	var handled_LpPacket bool = false

	progress := -1
	_ = progress

	value := &FwPacket{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 5:
				if true {
					handled = true
					handled_Interest = true
					value.Interest, err = context.Interest_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 6:
				if true {
					handled = true
					handled_Data = true
					value.Data, err = context.Data_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 100:
				if true {
					handled = true
					handled_LpPacket = true
					value.LpPacket, err = context.LpPacket_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Interest && err == nil {
		value.Interest = nil
	}
	if !handled_Data && err == nil {
		value.Data = nil
	}
	if !handled_LpPacket && err == nil {
		value.LpPacket = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwPacket) Encode() enc.Wire {
	encoder := FwPacketEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwPacket) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwPacket(reader enc.WireView, ignoreCritical bool) (*FwPacket, error) {
	context := FwPacketParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwInterestEncoder struct {
	Length uint

	wirePlan []uint

	NameV_length uint

	ForwardingHintV_encoder FwLinksEncoder
}

type FwInterestParsingContext struct {
	ForwardingHintV_context FwLinksParsingContext
}

func (encoder *FwInterestEncoder) Init(value *FwInterest) {
	if value.NameV != nil {
		encoder.NameV_length = 0
		for _, c := range value.NameV {
			encoder.NameV_length += uint(c.EncodingLength())
		}
	}

	if value.ForwardingHintV != nil {
		encoder.ForwardingHintV_encoder.Init(value.ForwardingHintV)
	}

	l := uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.CanBePrefixV {
		l += 1
		l += 1
	}
	if value.MustBeFreshV {
		l += 1
		l += 1
	}
	if value.ForwardingHintV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.ForwardingHintV_encoder.Length).EncodingLength())
		l += encoder.ForwardingHintV_encoder.Length
	}
	if value.NonceV.IsSet() {
		l += 1
		l += 1 + 4
	}
	if optval, ok := value.InterestLifetimeV.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(uint64(optval/time.Millisecond)).EncodingLength())
	}
	if value.HopLimitV != nil {
		l += 1
		l += 2
	}
	if value.ApplicationParameters {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.CanBePrefixV {
		l += 1
		l += 1
	}
	if value.MustBeFreshV {
		l += 1
		l += 1
	}
	if value.ForwardingHintV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.ForwardingHintV_encoder.Length).EncodingLength())
		l += encoder.ForwardingHintV_encoder.Length
	}
	if value.NonceV.IsSet() {
		l += 1
		l += 1 + 4
	}
	if optval, ok := value.InterestLifetimeV.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(uint64(optval/time.Millisecond)).EncodingLength())
	}
	if value.HopLimitV != nil {
		l += 1
		l += 2
	}
	if value.ApplicationParameters {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *FwInterestParsingContext) Init() {

	context.ForwardingHintV_context.Init()

}

func (encoder *FwInterestEncoder) EncodeInto(value *FwInterest, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.NameV != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NameV_length).EncodeInto(buf[pos:]))
		for _, c := range value.NameV {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.CanBePrefixV {
		buf[pos] = byte(33)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.MustBeFreshV {
		buf[pos] = byte(18)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.ForwardingHintV != nil {
		buf[pos] = byte(30)
		pos += 1
		pos += uint(enc.TLNum(encoder.ForwardingHintV_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.ForwardingHintV_encoder.Length > 0 {
			encoder.ForwardingHintV_encoder.EncodeInto(value.ForwardingHintV, buf[pos:])
			pos += encoder.ForwardingHintV_encoder.Length
		}
	}
	if optval, ok := value.NonceV.Get(); ok {
		buf[pos] = byte(10)
		pos += 1
		buf[pos] = 4
		binary.BigEndian.PutUint32(buf[pos+1:], uint32(optval))
		pos += 5
	}
	if optval, ok := value.InterestLifetimeV.Get(); ok {
		buf[pos] = byte(12)
		pos += 1

		buf[pos] = byte(enc.Nat(uint64(optval / time.Millisecond)).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.HopLimitV != nil {
		buf[pos] = byte(34)
		pos += 1
		buf[pos] = 1
		buf[pos+1] = byte(*value.HopLimitV)
		pos += 2
	}
	if value.ApplicationParameters {
		buf[pos] = byte(36)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureInfo {
		buf[pos] = byte(44)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureValue {
		buf[pos] = byte(46)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
}

func (encoder *FwInterestEncoder) Encode(value *FwInterest) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *FwInterestParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwInterest, error) {

	var handled_NameV bool = false
	var handled_CanBePrefixV bool = false
	var handled_MustBeFreshV bool = false
	var handled_ForwardingHintV bool = false
	var handled_NonceV bool = false
	var handled_InterestLifetimeV bool = false
	var handled_HopLimitV bool = false
	var handled_ApplicationParameters bool = false
	var handled_SignatureInfo bool = false
	var handled_SignatureValue bool = false

	progress := -1
	_ = progress

	value := &FwInterest{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NameV = true
					delegate := reader.Delegate(int(l))
					value.NameV, err = delegate.ReadName()
				}
			case 33:
				if true {
					handled = true
					handled_CanBePrefixV = true
					value.CanBePrefixV = true
					err = reader.Skip(int(l))
				}
			case 18:
				if true {
					handled = true
					handled_MustBeFreshV = true
					value.MustBeFreshV = true
					err = reader.Skip(int(l))
				}
			case 30:
				if true {
					handled = true
					handled_ForwardingHintV = true
					value.ForwardingHintV, err = context.ForwardingHintV_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 10:
				if true {
					handled = true
					handled_NonceV = true
					{
						optval := uint32(0)
						optval = uint32(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint32(optval<<8) | uint32(x)
							}
						}
						value.NonceV.Set(optval)
					}
				}
			case 12:
				if true {
					handled = true
					handled_InterestLifetimeV = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						optval := time.Duration(timeInt) * time.Millisecond
						value.InterestLifetimeV.Set(optval)
					}
				}
			case 34:
				if true {
					handled = true
					handled_HopLimitV = true
					{
						buf, err := reader.ReadBuf(1)
						if err == io.EOF {
							err = io.ErrUnexpectedEOF
						}
						value.HopLimitV = &buf[0]
					}
				}
			case 36:
				if true {
					handled = true
					handled_ApplicationParameters = true
					value.ApplicationParameters = true
					err = reader.Skip(int(l))
				}
			case 44:
				if true {
					handled = true
					handled_SignatureInfo = true
					value.SignatureInfo = true
					err = reader.Skip(int(l))
				}
			case 46:
				if true {
					handled = true
					handled_SignatureValue = true
					value.SignatureValue = true
					err = reader.Skip(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NameV && err == nil {
		value.NameV = nil
	}
	if !handled_CanBePrefixV && err == nil {
		value.CanBePrefixV = false
	}
	if !handled_MustBeFreshV && err == nil {
		value.MustBeFreshV = false
	}
	if !handled_ForwardingHintV && err == nil {
		value.ForwardingHintV = nil
	}
	if !handled_NonceV && err == nil {
		value.NonceV.Unset()
	}
	if !handled_InterestLifetimeV && err == nil {
		value.InterestLifetimeV.Unset()
	}
	if !handled_HopLimitV && err == nil {
		value.HopLimitV = nil
	}
	if !handled_ApplicationParameters && err == nil {
		value.ApplicationParameters = false
	}
	if !handled_SignatureInfo && err == nil {
		value.SignatureInfo = false
	}
	if !handled_SignatureValue && err == nil {
		value.SignatureValue = false
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwInterest) Encode() enc.Wire {
	encoder := FwInterestEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwInterest) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwInterest(reader enc.WireView, ignoreCritical bool) (*FwInterest, error) {
	context := FwInterestParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwLinksEncoder struct {
	Length uint

	Names_subencoder []struct {
		Names_length uint
	}
}

type FwLinksParsingContext struct {
}

func (encoder *FwLinksEncoder) Init(value *FwLinks) {
	{
		Names_l := len(value.Names)
		encoder.Names_subencoder = make([]struct {
			Names_length uint
		}, Names_l)
		for i := 0; i < Names_l; i++ {
			pseudoEncoder := &encoder.Names_subencoder[i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: value.Names[i],
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					encoder.Names_length = 0
					for _, c := range value.Names {
						encoder.Names_length += uint(c.EncodingLength())
					}
				}
				_ = encoder
				_ = value
			}
		}
	}

	l := uint(0)
	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					l += 1
					l += uint(enc.TLNum(encoder.Names_length).EncodingLength())
					l += encoder.Names_length
				}
				_ = encoder
				_ = value
			}
		}
	}
	encoder.Length = l

}

func (context *FwLinksParsingContext) Init() {

}

func (encoder *FwLinksEncoder) EncodeInto(value *FwLinks, buf []byte) {

	pos := uint(0)

	if value.Names != nil {
		for seq_i, seq_v := range value.Names {
			pseudoEncoder := &encoder.Names_subencoder[seq_i]
			pseudoValue := struct {
				Names enc.Name
			}{
				Names: seq_v,
			}
			{
				encoder := pseudoEncoder
				value := &pseudoValue
				if value.Names != nil {
					buf[pos] = byte(7)
					pos += 1
					pos += uint(enc.TLNum(encoder.Names_length).EncodeInto(buf[pos:]))
					for _, c := range value.Names {
						pos += uint(c.EncodeInto(buf[pos:]))
					}
				}
				_ = encoder
				_ = value
			}
		}
	}
}

func (encoder *FwLinksEncoder) Encode(value *FwLinks) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FwLinksParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwLinks, error) {

	var handled_Names bool = false

	progress := -1
	_ = progress

	value := &FwLinks{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_Names = true
					if value.Names == nil {
						value.Names = make([]enc.Name, 0)
					}
					{
						pseudoValue := struct {
							Names enc.Name
						}{}
						{
							value := &pseudoValue
							delegate := reader.Delegate(int(l))
							value.Names, err = delegate.ReadName()
							_ = value
						}
						value.Names = append(value.Names, pseudoValue.Names)
					}
					progress--
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Names && err == nil {
		// sequence - skip
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwLinks) Encode() enc.Wire {
	encoder := FwLinksEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwLinks) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwLinks(reader enc.WireView, ignoreCritical bool) (*FwLinks, error) {
	context := FwLinksParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwDataEncoder struct {
	Length uint

	wirePlan []uint

	NameV_length     uint
	MetaInfo_encoder FwMetaInfoEncoder
}

type FwDataParsingContext struct {
	MetaInfo_context FwMetaInfoParsingContext
}

func (encoder *FwDataEncoder) Init(value *FwData) {
	if value.NameV != nil {
		encoder.NameV_length = 0
		for _, c := range value.NameV {
			encoder.NameV_length += uint(c.EncodingLength())
		}
	}
	if value.MetaInfo != nil {
		encoder.MetaInfo_encoder.Init(value.MetaInfo)
	}

	l := uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.MetaInfo != nil {
		l += 1
		l += uint(enc.TLNum(encoder.MetaInfo_encoder.Length).EncodingLength())
		l += encoder.MetaInfo_encoder.Length
	}
	if value.ContentV {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.NameV != nil {
		l += 1
		l += uint(enc.TLNum(encoder.NameV_length).EncodingLength())
		l += encoder.NameV_length
	}
	if value.MetaInfo != nil {
		l += 1
		l += uint(enc.TLNum(encoder.MetaInfo_encoder.Length).EncodingLength())
		l += encoder.MetaInfo_encoder.Length
	}
	if value.ContentV {
		l += 1
		l += 1
	}
	if value.SignatureInfo {
		l += 1
		l += 1
	}
	if value.SignatureValue {
		l += 1
		l += 1
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *FwDataParsingContext) Init() {

	context.MetaInfo_context.Init()

}

func (encoder *FwDataEncoder) EncodeInto(value *FwData, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if value.NameV != nil {
		buf[pos] = byte(7)
		pos += 1
		pos += uint(enc.TLNum(encoder.NameV_length).EncodeInto(buf[pos:]))
		for _, c := range value.NameV {
			pos += uint(c.EncodeInto(buf[pos:]))
		}
	}
	if value.MetaInfo != nil {
		buf[pos] = byte(20)
		pos += 1
		pos += uint(enc.TLNum(encoder.MetaInfo_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.MetaInfo_encoder.Length > 0 {
			encoder.MetaInfo_encoder.EncodeInto(value.MetaInfo, buf[pos:])
			pos += encoder.MetaInfo_encoder.Length
		}
	}
	if value.ContentV {
		buf[pos] = byte(21)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureInfo {
		buf[pos] = byte(22)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
	if value.SignatureValue {
		buf[pos] = byte(23)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
}

func (encoder *FwDataEncoder) Encode(value *FwData) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *FwDataParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwData, error) {

	var handled_NameV bool = false
	var handled_MetaInfo bool = false
	var handled_ContentV bool = false
	var handled_SignatureInfo bool = false
	var handled_SignatureValue bool = false

	progress := -1
	_ = progress

	value := &FwData{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 7:
				if true {
					handled = true
					handled_NameV = true
					delegate := reader.Delegate(int(l))
					value.NameV, err = delegate.ReadName()
				}
			case 20:
				if true {
					handled = true
					handled_MetaInfo = true
					value.MetaInfo, err = context.MetaInfo_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 21:
				if true {
					handled = true
					handled_ContentV = true
					value.ContentV = true
					err = reader.Skip(int(l))
				}
			case 22:
				if true {
					handled = true
					handled_SignatureInfo = true
					value.SignatureInfo = true
					err = reader.Skip(int(l))
				}
			case 23:
				if true {
					handled = true
					handled_SignatureValue = true
					value.SignatureValue = true
					err = reader.Skip(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_NameV && err == nil {
		value.NameV = nil
	}
	if !handled_MetaInfo && err == nil {
		value.MetaInfo = nil
	}
	if !handled_ContentV && err == nil {
		value.ContentV = false
	}
	if !handled_SignatureInfo && err == nil {
		value.SignatureInfo = false
	}
	if !handled_SignatureValue && err == nil {
		value.SignatureValue = false
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwData) Encode() enc.Wire {
	encoder := FwDataEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwData) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwData(reader enc.WireView, ignoreCritical bool) (*FwData, error) {
	context := FwDataParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwMetaInfoEncoder struct {
	Length uint
}

type FwMetaInfoParsingContext struct {
}

func (encoder *FwMetaInfoEncoder) Init(value *FwMetaInfo) {

	l := uint(0)
	if optval, ok := value.ContentType.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.FreshnessPeriod.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(uint64(optval/time.Millisecond)).EncodingLength())
	}
	if value.FinalBlockID {
		l += 1
		l += 1
	}
	encoder.Length = l

}

func (context *FwMetaInfoParsingContext) Init() {

}

func (encoder *FwMetaInfoEncoder) EncodeInto(value *FwMetaInfo, buf []byte) {

	pos := uint(0)

	if optval, ok := value.ContentType.Get(); ok {
		buf[pos] = byte(24)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.FreshnessPeriod.Get(); ok {
		buf[pos] = byte(25)
		pos += 1

		buf[pos] = byte(enc.Nat(uint64(optval / time.Millisecond)).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.FinalBlockID {
		buf[pos] = byte(26)
		pos += 1
		buf[pos] = byte(0)
		pos += 1
	}
}

func (encoder *FwMetaInfoEncoder) Encode(value *FwMetaInfo) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FwMetaInfoParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwMetaInfo, error) {

	var handled_ContentType bool = false
	var handled_FreshnessPeriod bool = false
	var handled_FinalBlockID bool = false

	progress := -1
	_ = progress

	value := &FwMetaInfo{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 24:
				if true {
					handled = true
					handled_ContentType = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.ContentType.Set(optval)
					}
				}
			case 25:
				if true {
					handled = true
					handled_FreshnessPeriod = true
					{
						timeInt := uint64(0)
						timeInt = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								timeInt = uint64(timeInt<<8) | uint64(x)
							}
						}
						optval := time.Duration(timeInt) * time.Millisecond
						value.FreshnessPeriod.Set(optval)
					}
				}
			case 26:
				if true {
					handled = true
					handled_FinalBlockID = true
					value.FinalBlockID = true
					err = reader.Skip(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_ContentType && err == nil {
		value.ContentType.Unset()
	}
	if !handled_FreshnessPeriod && err == nil {
		value.FreshnessPeriod.Unset()
	}
	if !handled_FinalBlockID && err == nil {
		value.FinalBlockID = false
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwMetaInfo) Encode() enc.Wire {
	encoder := FwMetaInfoEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwMetaInfo) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwMetaInfo(reader enc.WireView, ignoreCritical bool) (*FwMetaInfo, error) {
	context := FwMetaInfoParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwLpPacketEncoder struct {
	Length uint

	wirePlan []uint

	Nack_encoder FwNetworkNackEncoder

	CachePolicy_encoder FwCachePolicyEncoder

	Fragment_length uint
}

type FwLpPacketParsingContext struct {
	Nack_context FwNetworkNackParsingContext

	CachePolicy_context FwCachePolicyParsingContext
}

func (encoder *FwLpPacketEncoder) Init(value *FwLpPacket) {

	if value.Nack != nil {
		encoder.Nack_encoder.Init(value.Nack)
	}

	if value.CachePolicy != nil {
		encoder.CachePolicy_encoder.Init(value.CachePolicy)
	}

	if value.Fragment != nil {
		encoder.Fragment_length = 0
		for _, c := range value.Fragment {
			encoder.Fragment_length += uint(len(c))
		}
	}

	l := uint(0)
	if value.Sequence.IsSet() {
		l += 1
		l += 1 + 8
	}
	if optval, ok := value.FragIndex.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.FragCount.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.PitToken != nil {
		l += 1
		l += uint(enc.TLNum(len(value.PitToken)).EncodingLength())
		l += uint(len(value.PitToken))
	}
	if value.Nack != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Nack_encoder.Length).EncodingLength())
		l += encoder.Nack_encoder.Length
	}
	if optval, ok := value.IncomingFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.NextHopFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.CachePolicy != nil {
		l += 3
		l += uint(enc.TLNum(encoder.CachePolicy_encoder.Length).EncodingLength())
		l += encoder.CachePolicy_encoder.Length
	}
	if optval, ok := value.CongestionMark.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Fragment != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Fragment_length).EncodingLength())
		l += encoder.Fragment_length
	}
	encoder.Length = l

	wirePlan := make([]uint, 0, 8)
	l = uint(0)
	if value.Sequence.IsSet() {
		l += 1
		l += 1 + 8
	}
	if optval, ok := value.FragIndex.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.FragCount.Get(); ok {
		l += 1
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.PitToken != nil {
		l += 1
		l += uint(enc.TLNum(len(value.PitToken)).EncodingLength())
		l += uint(len(value.PitToken))
	}
	if value.Nack != nil {
		l += 3
		l += uint(enc.TLNum(encoder.Nack_encoder.Length).EncodingLength())
		l += encoder.Nack_encoder.Length
	}
	if optval, ok := value.IncomingFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if optval, ok := value.NextHopFaceId.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.CachePolicy != nil {
		l += 3
		l += uint(enc.TLNum(encoder.CachePolicy_encoder.Length).EncodingLength())
		l += encoder.CachePolicy_encoder.Length
	}
	if optval, ok := value.CongestionMark.Get(); ok {
		l += 3
		l += uint(1 + enc.Nat(optval).EncodingLength())
	}
	if value.Fragment != nil {
		l += 1
		l += uint(enc.TLNum(encoder.Fragment_length).EncodingLength())
		wirePlan = append(wirePlan, l)
		l = 0
		for range value.Fragment {
			wirePlan = append(wirePlan, l)
			l = 0
		}
	}
	if l > 0 {
		wirePlan = append(wirePlan, l)
	}
	encoder.wirePlan = wirePlan
}

func (context *FwLpPacketParsingContext) Init() {

	context.Nack_context.Init()

	context.CachePolicy_context.Init()

}

func (encoder *FwLpPacketEncoder) EncodeInto(value *FwLpPacket, wire enc.Wire) {

	wireIdx := 0
	buf := wire[wireIdx]

	pos := uint(0)

	if optval, ok := value.Sequence.Get(); ok {
		buf[pos] = byte(81)
		pos += 1
		buf[pos] = 8
		binary.BigEndian.PutUint64(buf[pos+1:], uint64(optval))
		pos += 9
	}
	if optval, ok := value.FragIndex.Get(); ok {
		buf[pos] = byte(82)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.FragCount.Get(); ok {
		buf[pos] = byte(83)
		pos += 1

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.PitToken != nil {
		buf[pos] = byte(98)
		pos += 1
		pos += uint(enc.TLNum(len(value.PitToken)).EncodeInto(buf[pos:]))
		copy(buf[pos:], value.PitToken)
		pos += uint(len(value.PitToken))
	}
	if value.Nack != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(800))
		pos += 3
		pos += uint(enc.TLNum(encoder.Nack_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.Nack_encoder.Length > 0 {
			encoder.Nack_encoder.EncodeInto(value.Nack, buf[pos:])
			pos += encoder.Nack_encoder.Length
		}
	}
	if optval, ok := value.IncomingFaceId.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(812))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if optval, ok := value.NextHopFaceId.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(816))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.CachePolicy != nil {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(820))
		pos += 3
		pos += uint(enc.TLNum(encoder.CachePolicy_encoder.Length).EncodeInto(buf[pos:]))
		if encoder.CachePolicy_encoder.Length > 0 {
			encoder.CachePolicy_encoder.EncodeInto(value.CachePolicy, buf[pos:])
			pos += encoder.CachePolicy_encoder.Length
		}
	}
	if optval, ok := value.CongestionMark.Get(); ok {
		buf[pos] = 253
		binary.BigEndian.PutUint16(buf[pos+1:], uint16(832))
		pos += 3

		buf[pos] = byte(enc.Nat(optval).EncodeInto(buf[pos+1:]))
		pos += uint(1 + buf[pos])

	}
	if value.Fragment != nil {
		buf[pos] = byte(80)
		pos += 1
		pos += uint(enc.TLNum(encoder.Fragment_length).EncodeInto(buf[pos:]))
		wireIdx++
		pos = 0
		if wireIdx < len(wire) {
			buf = wire[wireIdx]
		} else {
			buf = nil
		}
		for _, w := range value.Fragment {
			wire[wireIdx] = w
			wireIdx++
			pos = 0
			if wireIdx < len(wire) {
				buf = wire[wireIdx]
			} else {
				buf = nil
			}
		}
	}
}

func (encoder *FwLpPacketEncoder) Encode(value *FwLpPacket) enc.Wire {
	total := uint(0)
	for _, l := range encoder.wirePlan {
		total += l
	}
	content := make([]byte, total)

	wire := make(enc.Wire, len(encoder.wirePlan))
	for i, l := range encoder.wirePlan {
		if l > 0 {
			wire[i] = content[:l]
			content = content[l:]
		}
	}
	encoder.EncodeInto(value, wire)

	return wire
}

func (context *FwLpPacketParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwLpPacket, error) {

	var handled_Sequence bool = false
	var handled_FragIndex bool = false
	var handled_FragCount bool = false
	var handled_PitToken bool = false
	var handled_Nack bool = false
	var handled_IncomingFaceId bool = false
	var handled_NextHopFaceId bool = false
	var handled_CachePolicy bool = false
	var handled_CongestionMark bool = false
	var handled_Fragment bool = false

	progress := -1
	_ = progress

	value := &FwLpPacket{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 81:
				if true {
					handled = true
					handled_Sequence = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.Sequence.Set(optval)
					}
				}
			case 82:
				if true {
					handled = true
					handled_FragIndex = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.FragIndex.Set(optval)
					}
				}
			case 83:
				if true {
					handled = true
					handled_FragCount = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.FragCount.Set(optval)
					}
				}
			case 98:
				if true {
					handled = true
					handled_PitToken = true
					value.PitToken = make([]byte, l)
					_, err = reader.ReadFull(value.PitToken)
				}
			case 800:
				if true {
					handled = true
					handled_Nack = true
					value.Nack, err = context.Nack_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 812:
				if true {
					handled = true
					handled_IncomingFaceId = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.IncomingFaceId.Set(optval)
					}
				}
			case 816:
				if true {
					handled = true
					handled_NextHopFaceId = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.NextHopFaceId.Set(optval)
					}
				}
			case 820:
				if true {
					handled = true
					handled_CachePolicy = true
					value.CachePolicy, err = context.CachePolicy_context.Parse(reader.Delegate(int(l)), ignoreCritical)
				}
			case 832:
				if true {
					handled = true
					handled_CongestionMark = true
					{
						optval := uint64(0)
						optval = uint64(0)
						{
							for i := 0; i < int(l); i++ {
								x := byte(0)
								x, err = reader.ReadByte()
								if err != nil {
									if err == io.EOF {
										err = io.ErrUnexpectedEOF
									}
									break
								}
								optval = uint64(optval<<8) | uint64(x)
							}
						}
						value.CongestionMark.Set(optval)
					}
				}
			case 80:
				if true {
					handled = true
					handled_Fragment = true
					value.Fragment, err = reader.ReadWire(int(l))
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Sequence && err == nil {
		value.Sequence.Unset()
	}
	if !handled_FragIndex && err == nil {
		value.FragIndex.Unset()
	}
	if !handled_FragCount && err == nil {
		value.FragCount.Unset()
	}
	if !handled_PitToken && err == nil {
		value.PitToken = nil
	}
	if !handled_Nack && err == nil {
		value.Nack = nil
	}
	if !handled_IncomingFaceId && err == nil {
		value.IncomingFaceId.Unset()
	}
	if !handled_NextHopFaceId && err == nil {
		value.NextHopFaceId.Unset()
	}
	if !handled_CachePolicy && err == nil {
		value.CachePolicy = nil
	}
	if !handled_CongestionMark && err == nil {
		value.CongestionMark.Unset()
	}
	if !handled_Fragment && err == nil {
		value.Fragment = nil
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwLpPacket) Encode() enc.Wire {
	encoder := FwLpPacketEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwLpPacket) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwLpPacket(reader enc.WireView, ignoreCritical bool) (*FwLpPacket, error) {
	context := FwLpPacketParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwNetworkNackEncoder struct {
	Length uint
}

type FwNetworkNackParsingContext struct {
}

func (encoder *FwNetworkNackEncoder) Init(value *FwNetworkNack) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.Reason).EncodingLength())
	encoder.Length = l

}

func (context *FwNetworkNackParsingContext) Init() {

}

func (encoder *FwNetworkNackEncoder) EncodeInto(value *FwNetworkNack, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(801))
	pos += 3

	buf[pos] = byte(enc.Nat(value.Reason).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

func (encoder *FwNetworkNackEncoder) Encode(value *FwNetworkNack) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FwNetworkNackParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwNetworkNack, error) {

	var handled_Reason bool = false

	progress := -1
	_ = progress

	value := &FwNetworkNack{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 801:
				if true {
					handled = true
					handled_Reason = true
					value.Reason = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.Reason = uint64(value.Reason<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_Reason && err == nil {
		err = enc.ErrSkipRequired{Name: "Reason", TypeNum: 801}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwNetworkNack) Encode() enc.Wire {
	encoder := FwNetworkNackEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwNetworkNack) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwNetworkNack(reader enc.WireView, ignoreCritical bool) (*FwNetworkNack, error) {
	context := FwNetworkNackParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}

type FwCachePolicyEncoder struct {
	Length uint
}

type FwCachePolicyParsingContext struct {
}

func (encoder *FwCachePolicyEncoder) Init(value *FwCachePolicy) {

	l := uint(0)
	l += 3
	l += uint(1 + enc.Nat(value.CachePolicyType).EncodingLength())
	encoder.Length = l

}

func (context *FwCachePolicyParsingContext) Init() {

}

func (encoder *FwCachePolicyEncoder) EncodeInto(value *FwCachePolicy, buf []byte) {

	pos := uint(0)

	buf[pos] = 253
	binary.BigEndian.PutUint16(buf[pos+1:], uint16(821))
	pos += 3

	buf[pos] = byte(enc.Nat(value.CachePolicyType).EncodeInto(buf[pos+1:]))
	pos += uint(1 + buf[pos])
}

func (encoder *FwCachePolicyEncoder) Encode(value *FwCachePolicy) enc.Wire {

	wire := make(enc.Wire, 1)
	wire[0] = make([]byte, encoder.Length)
	buf := wire[0]
	encoder.EncodeInto(value, buf)

	return wire
}

func (context *FwCachePolicyParsingContext) Parse(reader enc.WireView, ignoreCritical bool) (*FwCachePolicy, error) {

	var handled_CachePolicyType bool = false

	progress := -1
	_ = progress

	value := &FwCachePolicy{}
	var err error
	var startPos int
	for {
		startPos = reader.Pos()
		if startPos >= reader.Length() {
			break
		}
		typ := enc.TLNum(0)
		l := enc.TLNum(0)
		typ, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}
		l, err = reader.ReadTLNum()
		if err != nil {
			return nil, enc.ErrFailToParse{TypeNum: 0, Err: err}
		}

		err = nil
		if handled := false; true {
			switch typ {
			case 821:
				if true {
					handled = true
					handled_CachePolicyType = true
					value.CachePolicyType = uint64(0)
					{
						for i := 0; i < int(l); i++ {
							x := byte(0)
							x, err = reader.ReadByte()
							if err != nil {
								if err == io.EOF {
									err = io.ErrUnexpectedEOF
								}
								break
							}
							value.CachePolicyType = uint64(value.CachePolicyType<<8) | uint64(x)
						}
					}
				}
			default:
				if !ignoreCritical && ((typ <= 31) || ((typ & 1) == 1)) {
					return nil, enc.ErrUnrecognizedField{TypeNum: typ}
				}
				handled = true
				err = reader.Skip(int(l))
			}
			if err == nil && !handled {
			}
			if err != nil {
				return nil, enc.ErrFailToParse{TypeNum: typ, Err: err}
			}
		}
	}

	startPos = reader.Pos()
	err = nil

	if !handled_CachePolicyType && err == nil {
		err = enc.ErrSkipRequired{Name: "CachePolicyType", TypeNum: 821}
	}

	if err != nil {
		return nil, err
	}

	return value, nil
}

func (value *FwCachePolicy) Encode() enc.Wire {
	encoder := FwCachePolicyEncoder{}
	encoder.Init(value)
	return encoder.Encode(value)
}

func (value *FwCachePolicy) Bytes() []byte {
	return value.Encode().Join()
}

func ParseFwCachePolicy(reader enc.WireView, ignoreCritical bool) (*FwCachePolicy, error) {
	context := FwCachePolicyParsingContext{}
	context.Init()
	return context.Parse(reader, ignoreCritical)
}
